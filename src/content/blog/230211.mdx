---
title: "웹의 상상력, 그 너머로"
description: "궁극의 어플리케이션 경험과 프론트엔드의 미래에 대해 알아봅니다."
pubDate: "2099-01-01"
heroImage: "/new-era-frontend-hero.jpg"
draft: true
---

바야흐로 춘추전국시대입니다. 아, 정치나 경제 사회 이야기가 아닙니다. 당신이 지금 보고 있는 디스플레이에 대한 이야기죠. 좀 더 정확히는, 디스플레이에 뿌려지는 어플리케이션에 대한 이야기입니다.

이 시대는 눈부신 기술 발전의 끝에 어플리케이션으로 뒤덮였습니다. 삶을 유지하는데 필요한 거의 대부분의 것들이 어플리케이션으로 제공됩니다. 앱스토어에서 앱을 설치하고, 웹으로 서비스 홈페이지에 접속하고, 이메일로 뉴스레터를 받아보죠. 프론트엔드 개발자로서 오늘은 웹이 어디서 왔고 어디로 나아가고 있는지 알아보려고 합니다.

# 프론트엔드의 기원

최초의 웹은 문서를 공유하기 위해 탄생했습니다. 유수의 대학과 군사기관에서 서류를 주고받는 작업이 더욱 견고한 시스템 위에서 움직이도록 말이죠. 그리고 웹을 탐색하기 위한 브라우저가 있었습니다. 문서와 문서는 하이퍼링크로 연결되고, 사람들은 이 문서에서 저 문서로 넘어다니며 웹의 세계를 돌아다닐 수 있었죠.

모든 플랫폼이 그렇듯 사람들은 웹에 점점 더 많은 기능을 추가하고 싶어했습니다. 문서를 더 아름답고 가독성 있게 꾸미기 위한 스타일시트가 추가되고, 간단한 스크립팅을 통해서 탐색과 읽기를 위한 기능을 구현했죠. 그렇게 수많은 홈페이지가 탄생하며 브라우저 전쟁의 시대가 열립니다. 더욱 풍부한 기능, 화려한 스타일, 빠른 속도를 위해서 말이죠. 강력한 브라우저는 사람들의 상상력을 자극하고 더 복잡한 문서를 가능하게 했습니다. 웹 어플리케이션의 도래였죠. 이제 웹, 브라우저는 단순이 문서의 집합과 리더기가 아니게 되었습니다. 무제한의 앱 스토어와 그 구동장치, 즉 런타임이 된 것이죠.

## 그럼.. 지금은요?

시계를 조금 빠르게 돌려 현재로 와보면, 전통적인 웹 개발자였던 백엔드 개발자의 옆에 프론트엔드 개발자라는 직군이 생겼습니다. 웹 어플리케이션의 설계와 개발의 복잡도가 한 사람의 새로운 전문적인 개발자를 필요로 할 만큼 증가했다는 뜻입니다. Backbone.js, Angular.js, 그리고 2020년을 지배하고 있는 React 까지, 프론트엔드 개발자는 강력하고 스마트한 프레임워크를 통해 훌륭한 웹 앱을 제공하고 있습니다. 그런데 뭔가 이상합니다. 이만하면 참 훌륭한 것 같은데, 여전히 불편함을 느끼고 새로운 것을 만드는 사람들이 있습니다.

전 요즘 arc 라는 브라우저를 즐겁게 사용하고 있는데요. 기존의 전통적인 탭과 확장프로그램 조합인 브라우저의 틀을 깨겠다는 원대한 포부를 갖고 태어난 프로그램입니다. 웹 프레임워크의 흐름도 이와 비슷합니다. 현재를 장악하고 있는 패러다임의 한계를 지적하고 이를 극복하는 영웅이 나타나고 있죠. Angular 가 그랬고, React 가 그랬습니다.

## 만능이 아닙니다

웹의 근본적인 특징이 무엇인가요? 처음 브라우저를 켜면 아무것도 없는 텅 빈 페이지가 나옵니다. 어플리케이션에 접근하기 위해 주소를 입력하는 순간 어플리케이션이 로드되기 시작합니다. 그리고 로드된 어플리케이션을 브라우저가 해석 및 구동하여 사용자의 화면에 나타나게 됩니다. 웹의 무한한 가능성이며 동시에 최악의 한계점이 여기에 있습니다. 언제 어디서나 접근할 수 있지만, 기다려야 합니다. 휴대전화에 설치된 앱을 실행하는 것에 비교하면 굉장히 다른 특성입니다. 앱은 미리 설치되어 있고 실행하는 순간 이미 열려있지만, 반드시 설치해야만 쓸 수 있고 새로운 버전이 나오면 업데이트를 해야 합니다. 웹은 정 반대죠. 브라우저만 있으면 거의 어떤 환경이든 실행할 수 있고 거의 항상 최신 어플리케이션을 바라보게 되지만, 네트워크의 품질에 따라 사용자 경험이 극단적으로 바뀔 수 있습니다. 최악의 경우에는 앱을 사용할 수 없게 되죠.

## 개발자도 사용자도 행복하도록

JavaScript 는 웹 문서에 스크립팅을 추가하기 위해 탄생했습니다. 배우기 쉽고, 브라우저의 기능을 풍부하게 활용해 더 다채로운 웹 경험을 만들고자 했습니다. 하지만 브라우저가 발전하면서 순수한 JavaScript 코드를 관리하는 것은 어려워지기 시작했습니다. 그래서 2006년, jQuery 가 탄생합니다. 더욱 간결한 코드로 문서를 조작하는 것에 초점을 맞췄습니다. 결과는 대박이었죠. 엄청나게 많은 웹사이트가 jQuery 를 이용해 설계되었습니다. 왜 그랬을까요? 더 쉽고 짧은 코드로 더 멋지고 아름다운 웹사이트를 만들 수 있었으니까요. 사용자 뿐만 아니라 개발자의 개발 경험도 한 단계 뛰어올랐던 것입니다.

그리고 2010년 Backbone.js 가 나타납니다. 단순한 스크립팅을 넘어서 웹 어플리케이션의 구조적인 설계를 돕는 프레임워크였죠. 저는 실제로 써본 적이 없어서 어떤 개발경험과 기능을 갖고 있는지는 잘 모릅니다만, 분명 시대를 장악할 만한 획기적인 아이디어로 가득찬 프레임워크였을 것이라고 생각합니다.

이제 컴포넌트의 시대가 열립니다. React, Angular, Vue 모두 비슷한 개념을 들고 나왔습니다. 여러가지 책임을 갖는 컴포넌트의 조합으로 풍부한 웹 앱 경험을 설계할 수 있게 되었습니다. 개발 경험도 기하급수적으로 성장하기 시작합니다. 강력한 에디터, 견고한 가이드 문서, 놀라운 생태계가 프론트엔드 개발자를 든든히 지원했습니다. 두려울 것이 없었죠. 세계는 점점 더 빠르고 유연한 웹 앱에 환호하고 있으니까요. React 는 네이티브 어플리케이션의 영역까지 넘보며 React Native 로 분기하기도 했습니다. 프론트엔드 프레임워크의 특이점이 찾아온 겁니다. 폭발적으로 늘어나는 웹 앱과 프레임워크 속에서 번뜩이는 아이디어로 무장한 스타트업들이 튀어나옵니다. Electron 을 등에 업고 앱스토어 시장까지 침공합니다. 아마 간단한 마크업으로 문서를 작성하던 그 시절의 사람들에게 웹 앱의 시대란 참으로 감격스러운 것일지도 모르겠습니다.

허나 여정은 여기서 끝나지 않습니다. 저는 프론트엔드가 새로운 국면을 맞이할 준비를 하고 있다고 생각합니다. 사실 이미 프론트엔드 개발자 대부분이 알고 있는 사실일지도 모릅니다. 웹 앱이 놀라울만큼 복잡해지면서 브라우저가 감당해야 할 코드의 분량 또한 너무나 크게 늘어났습니다. 웹의 핵심적인 특성으로 인해, 코드의 증가는 필연적으로 로드 시간의 증가를 가져오고, 이는 궁극적으로 사용자의 경험을 저해합니다. 동시에 개발자 또한 더욱 섬세하게 고민하며 프로그래밍을 해야 합니다. Qwik, Astro, Solid 같은 신세대는 이러한 복잡도의 증가를 지적하고 나섰습니다. 정확히는 복잡해지는 이 시스템에 방향을 제시하고자 한 것이죠.

## 서버의 귀환

사실 극초기의 웹 앱은 프론트엔드 개발자가 만드는 것이 아니었습니다. 혹시 Python 의 Django 를 아시나요? Django 는 웹 앱 및 서버를 구축하는 훌륭한 Python 프레임워크 입니다. php 라는 것도 있습니다. 마찬가지로 서버에서 계산 및 실행하여 웹 앱을 제공하는 도구였습니다. Apache + php + MySQL (APM) stack 의 일부이기도 했죠. 웹 앱은 사실 서버에서 구동하는 것이었습니다. 왜 그랬을까요? 브라우저에서 실행하는 JavaScript 는 너무 느렸고, 할 수 있는게 별로 없었기 때문입니다. 데이터에 비동기적으로 접근하기도 어렵고, 거대한 html 을 순식간에 바꾸기도 어려웠습니다.

하지만 브라우저가 성장하면서 이런 한계는 점점 극복되기 시작했습니다. 자연스럽게 웹 앱을 JavaScript 로 구성하는 것이 인기를 얻게 되었습니다. 다양한 브라우저 API 를 이용해 서버 기반 웹 앱에서는 할 수 없는 일들을 처리하기 시작했습니다. 더 나아가면 Single Page Application (SPA) 로 전체 페이지 재 요청 없이 메뉴와 화면을 옮겨다니는 것도 가능해졌죠. 이 지점이 React 를 위시한 브라우저 JavaScript 웹 앱 프레임워크를 탄생하게 하고 동시에 인기를 얻게 한 지점입니다.

다시 한 번 브라우저와 웹 앱은 도전을 맞이합니다. 웹 앱으로 지금보다 더욱 복잡한 어플리케이션을 설계하면서 동시에 가볍고 빠른 경험을 추구해야 합니다. 기존의 패러다임이 여전히 유효할까요? 요구사항에 따라 다르겠지만 JavaScript 를 통째로 브라우저에 얹어서 실행하는 것은 한계가 있습니다. 어플리케이션이 거대하면 거대할 수록 JavaScript 로드와 bootstrap 을 오래 기다려야 하니까요.

그래서 Server Side Rendering 이 등장했습니다. 사실 SSR 의 등장은 조금 미묘한 부분이 있습니다. 서버에서 실행하는 웹 앱 프레임워크의 문제점을 탈피하기 위해 브라우저에서 완벽히 독립적으로 실행되는 프레임워크가 등장한 것인데, 다시 이것을 서버 환경에서 일부 실행하겠다는 생각이었으니까요. 하지만 이 생각은 훌륭했고, 초기로딩의 문제점을 상당히 잘 해결했습니다. 예전처럼 다시 사용자가 화면을 금방 볼 수 있게 되었으니까요. 물론 여기서 문제가 끝나지는 않습니다. SSR 은 Client Side Rendering (CSR) 보다 구현하기 어렵습니다. 서버와 클라이언트 양 쪽에서 모두 구동 가능한 코드를 작성해야 하고, 또 요청이 들어왔을 때 페이지를 일부 미리 그리는 서버 코드를 작성해야 합니다. 그래서 Next.js 같은 훌륭한 프레임워크가 등장합니다. SSR 이 좋은 건 알겠는데, 구축 비용이 상당하기 때문에 이를 더욱 간편하고 쉽게 해결해주기 위해서였죠. 어디서 많이 본 것 같지 않나요? jQuery 의 등장 배경과 정말 비슷합니다. 사실 세상의 모든 기술이란 것이 다 그렇긴 하죠.

여기까지가 현재 가장 주류인 SSR 의 등장배경입니다. 사실 Next.js 만 해도 웬만한 use case 는 모두 커버하고도 남아요. 프로덕션에서 사용하기에 가장 적합한 단계의 기술이기도 합니다. 수많은 사용처에서 검증되었으니까요.

# 다음은 무엇인가

SSR 도 있고, SSR 을 쉽게 만들어주는 프레임워크도 있고. 다 끝난 것 같네요? 아닙니다. 여전히 우리는 이야기할 주제를 많이 갖고 있어요. SSR 은 좋은 개념이었지만 개발자들은 사용자 경험과 개발자 경험을 더 극단으로 밀어붙이고 싶어 했습니다. 제가 볼 때 프론트엔드 커뮤니티가 궁극적으로 추구하는 것은 로드 즉시 매우 빠르고 가볍게 상호작용 가능한 초강력 프레임워크입니다. 더 자세하게는 그 프레임워크 자체가 프로덕션 환경에서는 사라지길 원하는 것 같습니다. No overhead, No Virtual DOM 을 지향한 Svelte 가 그 예시 중 하나입니다. 또한 복잡한 SSR 환경의 특징을 그다지 신경쓰고 싶지 않았습니다. 브라우저의 JavaScript 런타임과 서버 (비 브라우저)의 JavaScript 런타임은 기본적인 것은 비슷하지만 디테일한 API 는 서로 다른 것이 많습니다. 이런 점도 신경쓰지 않고 짧고 간단한 코드로 원하는 목적을 달성하고 싶어요. 코드는 모든 면에서 비용이니까요. 유지보수와 네트워크 처리 측면에서 말입니다.

SSR 은 hydration 이라는 과정을 필요로 합니다. 서버에서 생성한 html 문서와 이에 찰싹 붙어 가동될 JS 번들은 사실 서로를 잘 모릅니다. 브라우저는 각각을 내려 받아서 이어 붙이는 작업을 해야 합니다. 이것이 hydration 인데, 이 과정은 사실 CSR 과 별로 다를게 없습니다. 전체 페이지를 통째로 계산하고 event handler 를 각각의 html element 에 붙이는 과정은 긴 시간을 필요로 하고, 이 작업이 끝나기 전까지 사용자는 아무런 반응도 하지 않는 딱딱한 html 을 지켜봐야 합니다.

React 의 Suspense, Streaming rendering 은 이 문제를 우아하게 해결하려고 합니다. 개발자가 hydration 과정과 타이밍을 미세하게 조절하여 사용자 경험을 더 높이 끌어올릴 수 있습니다. 전체 페이지를 통째로 렌더링하는 것이 아닌 각 부분을 쪼개어 hydration 하고, 사용자와의 상호작용에 따라 이 hydration 순서를 실시간으로 변경합니다. 그래서 사용자는 마치 화면의 렌더링이 이미 완전히 마친 것 같은 착각을 느끼게 됩니다. 상당히 훌륭한 기법이죠. 하지만 이 방식은 사용자 경험을 개발자 개인의 프레임워크 숙련도에 의존하게 만듭니다. Suspense 를 잘 모르거나 써본 적이 없는 사람은 React 가 품고 있는 잠재력을 완전히 해방하기 힘든 것이죠.

Qwik, Astro 는 이 지점을 공략합니다. 사실 두 프레임워크의 사용법은 React 와 정말 비슷합니다. 이미 대부분의 프론트엔드 개발자가 React 를 사용하기 때문에 그들을 끌어들이려면 React-ish 해야 하는 측면도 있겠지만 그 이유가 아니더라도 React 가 제공했던 JSX 와 hook 경험은 Developer eXperience (DX) 를 정말 좋게 만들었거든요. 하지만 SSR 을 지원하면서 동시에 사용자 경험도 풍부하게 만들고 또 DX 까지 편안하게 유지하려면 프레임워크가 더 많은 일을 해줄 수 있어야 합니다.
